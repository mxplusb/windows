// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package kernel32

import (
	"syscall"
	"unsafe"

	"github.com/mxplusb/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return nil
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")

	procGetCurrentProcess     = modkernel32.NewProc("GetCurrentProcess")
	procQueryProcessCycleTime = modkernel32.NewProc("QueryProcessCycleTime")
	procGetLastError          = modkernel32.NewProc("GetLastError")
	procCreatePseudoConsole   = modkernel32.NewProc("CreatePseudoConsole")
	procResizePseudoConsole   = modkernel32.NewProc("ResizePseudoConsole")
	procClosePseudoConsole    = modkernel32.NewProc("ClosePseudoConsole")
	procGetComputerNameW      = modkernel32.NewProc("GetComputerNameW")
)

// GetCurrentProcess retrieves a pseudo handle for the current process. See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms683179%28v=vs.85%29.aspx
func GetCurrentProcess() (pseudoHandle windows.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetCurrentProcess.Addr(), 0, 0, 0, 0)
	pseudoHandle = windows.Handle(r0)
	if pseudoHandle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// QueryProcessCycleTime retrieves the sum of the cycle time of all threads of the specified process.
func QueryProcessCycleTime(handle windows.Handle, cycleTime *windows.PULong64) (err error) {
	r1, _, e1 := syscall.Syscall(procQueryProcessCycleTime.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(cycleTime)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// GetLastError retrieves the calling thread's last-error code value. The last-error code is maintained on a per-thread basis. Multiple threads do not overwrite each other's last-error code.
func GetLastError() (err error) {
	r1, _, e1 := syscall.Syscall(procGetLastError.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// CreatePseudoConsole creates a new pseudoconsole object for the calling process. See: https://docs.microsoft.com/en-us/windows/console/createpseudoconsole
func CreatePseudoConsole(size windows.COORD, hInput windows.Handle, hOutput windows.Handle, dwFlags windows.Dword, phPC *windows.HpCon) (err error) {
	r1, _, e1 := syscall.Syscall6(procCreatePseudoConsole.Addr(), 5, uintptr(unsafe.Alignof(size)), uintptr(hInput), uintptr(hOutput), uintptr(dwFlags), uintptr(unsafe.Pointer(phPC)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// ResizePseudoConsole resizes the internal buffers for a pseudoconsole to the given size. See: https://docs.microsoft.com/en-us/windows/console/resizepseudoconsole
func ResizePseudoConsole(hPC windows.HpCon, size windows.COORD) (err error) {
	r1, _, e1 := syscall.Syscall(procResizePseudoConsole.Addr(), 2, uintptr(hPC), uintptr(unsafe.Alignof(size)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// ClosePseudoConsole closes a pseudoconsole from the given handle. See: https://docs.microsoft.com/en-us/windows/console/closepseudoconsole
func ClosePseudoConsole(hPC windows.HpCon) (err error) {
	r1, _, e1 := syscall.Syscall(procClosePseudoConsole.Addr(), 1, uintptr(hPC), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getComputerName(lpBuffer *windows.LptStr, lpnSize *windows.LpdWord) (err error) {
	r1, _, e1 := syscall.Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(lpBuffer)), uintptr(unsafe.Pointer(lpnSize)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
