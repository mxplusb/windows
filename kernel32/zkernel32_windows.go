// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package kernel32

import (
	"syscall"
	"unsafe"

	"github.com/mxplusb/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return nil
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")

	procGetCurrentProcess     = modkernel32.NewProc("GetCurrentProcess")
	procQueryProcessCycleTime = modkernel32.NewProc("QueryProcessCycleTime")
	procGetLastError          = modkernel32.NewProc("GetLastError")
	procLoadLibraryW          = modkernel32.NewProc("LoadLibraryW")
	procGetProcAddress        = modkernel32.NewProc("GetProcAddress")
	procGetVersion            = modkernel32.NewProc("GetVersion")
	procGetComputerNameW      = modkernel32.NewProc("GetComputerNameW")
	procGetUserName           = modkernel32.NewProc("GetUserName")
)

// GetCurrentProcess retrieves a pseudo handle for the current process. See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms683179%28v=vs.85%29.aspx
func GetCurrentProcess() (pseudoHandle windows.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetCurrentProcess.Addr(), 0, 0, 0, 0)
	pseudoHandle = windows.Handle(r0)
	if pseudoHandle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// QueryProcessCycleTime retrieves the sum of the cycle time of all threads of the specified process.
func QueryProcessCycleTime(handle windows.Handle, cycleTime *windows.PULong64) (err error) {
	r1, _, e1 := syscall.Syscall(procQueryProcessCycleTime.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(cycleTime)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// GetLastError retrieves the calling thread's last-error code value. The last-error code is maintained on a per-thread basis. Multiple threads do not overwrite each other's last-error code.
func GetLastError() (err error) {
	r1, _, e1 := syscall.Syscall(procGetLastError.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func LoadLibrary(lpFileName string) (handle windows.Handle, err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(lpFileName)
	if err != nil {
		return
	}
	return _LoadLibrary(_p0)
}

func _LoadLibrary(lpFileName *uint16) (handle windows.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procLoadLibraryW.Addr(), 1, uintptr(unsafe.Pointer(lpFileName)), 0, 0)
	handle = windows.Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// GetProcAddress retrieves the address of an exported function or variable from the specified dynamic-link library (DLL). See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx
func GetProcAddress(hModule windows.Handle, lpProcName *byte) (addr windows.SizeT, err error) {
	r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(hModule), uintptr(unsafe.Pointer(lpProcName)), 0)
	addr = windows.SizeT(r0)
	if addr == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// GetVersion returns the OS version. See: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724439(v=vs.85).aspx
func GetVersion() (ver windows.Dword, err error) {
	r0, _, e1 := syscall.Syscall(procGetVersion.Addr(), 0, 0, 0, 0)
	ver = windows.Dword(r0)
	if ver == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getComputerName(lpBuffer *windows.LptStr, lpnSize *windows.LpdWord) (err error) {
	r1, _, e1 := syscall.Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(lpBuffer)), uintptr(unsafe.Pointer(lpnSize)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func getUserName(lpbuffer *windows.LptStr, lpnSize *windows.LpdWord) (err error) {
	r1, _, e1 := syscall.Syscall(procGetUserName.Addr(), 2, uintptr(unsafe.Pointer(lpbuffer)), uintptr(unsafe.Pointer(lpnSize)), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
